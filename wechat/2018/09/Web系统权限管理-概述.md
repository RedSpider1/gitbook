# 认证与授权
权限管理从大的方面来讲，分为两块：
- 认证(Authentication)：判断你是不是你本人，能不能登录系统
- 授权(authorization)：判断你有哪些权限，能不能进行某个操作

通常来说，“授权”都是在“认证”之后。也就是我们平时使用的业务逻辑：用户需要先登录，才能进行其他操作。

但有些时候，可能你的系统并不需要用户“登录”也可以进行一些操作，比如“看新闻”、“匿名评论”。那么这些相关权限就需要绕过“认证”和“授权”。

下面我们分别来聊聊“认证”和“授权”。

# 认证Authentication
前面说到，**认证**的功能是需要验证你是不是你本人。那么有哪些方法可以证明你是你本人呢？

## 使用用户名和密码
这里的用户名和密码都是用户在注册的时候自己输入的。那么设计一个安全系统需要考虑哪些东西呢？

- 密码是否需要定期更改？
- 密码的长度、复杂度的要求？
- 密码错误怎么处理？
    - 失败几次冻结？
        - 如何解冻？
            - 定时过后解冻
            - 找管理员申请解冻
            - 使用手机/邮箱验证码解冻
    - 失败几次需要验证？
        - 图片验证码
        - 手机验证码
        - 邮箱验证码
        - 滑块/点击验证
        - 其它
- 用户如何修改密码/忘记密码怎么办？
    - 登陆之后用户自己可以修改
    - 使用手机/邮箱验证码修改
    - 回答问题修改
- 创建账号的时候密码是用户自己输入的吗？是否可以自动生成？
    - 第一次登陆是否需要更改密码？
        - 如何判断第一次登陆？
- 登陆/注册/找回密码界面UI设计
    - 密码是否可切换“可见”
    - 密码或用户名错误该如何提示？
    - 账户冻结提示？
    - 图片验证码/滑块/点击验证
    - 输入框是否处理密码长度

## “记住我”功能
“记住我”(remember me)，指的是用户在登录后，服务器为这个用户生成一个**token**，用户记住这个token(使用cookie或者localStorage)，下次登录就只需要这个token就可以了。

使用“记住我”功能需要考虑什么？

- 服务端把token存在哪
    - 数据库，需要考虑查询性能的问题
    - 缓存(Redis)，需要考虑如何与用户关联起来
- token的过期时间？
    - 看每个应用自己的策略，一般是3天、七天都有
    - 如何检验过期？使用Redis的过期策略最好。或者在数据库增加一个时间字段辅助记录。
- 客户端把token存在哪？
    - cookie，优点是使用方便，确定是可能要处理跨域问题
    - localStorage
        - 请求时放到header里（**推荐**）
        - 请求时放到request参数/post body里

## 第三方登录
使用OAuth2。同时也是解决多个微服务统一认证的方案。后面会有文章专门介绍。它可以和前面两种方式结合起来使用，提供另外一种注册/登录的方式。

使用第三方登录需要注意的点是：
- 如果是外部系统的第三方，需要获取相应的client id和security key。
- 如果是外部系统的第三方，需要考虑如何把一个外部账号（比如微信号）关联到自己的账号。

## JWT
Json Web Token。也叫做“无状态”认证。使用Base64编码，把认证相关的信息(甚至是授权相关的信息）压缩为一个token，放到header里面。服务端进行解密，获取认证或授权相关的信息。

缺点是加密解密会耗费一定的性能，且每个请求都需要去加密解密token，不推荐在B/S架构中使用。

# 授权
授权决定的是**谁**对**什么资源**有/没有**什么操作**的权限。

简单来说，分为4个主体:
1. 允许还是禁止：allow/deny
2. 操作主体: 用户
3. 资源
4. 具体的操作：读、创建、更新、删除等

一般小型的权限系统中，基于权限最小原则，**第一个主体是可以没有的**，我们会默认一个用户最开始没有权限，然后赋予他一些权限。

操作主体是用户，但对每个用户都单独管理权限是一件很复杂的事，所以通常我们会使用“角色”、“组”、“部门”等概念来批量管理一些用户的权限，把权限(permissions)放到角色/组/部门下面统一管理，然后把用户挂在这些集合下面。

这样可能就会涉及到权限**重复**和权限**优先级**的问题。在简单的权限系统中，我们只有**allow**权限，所以不用太考虑**优先级**的问题。而权限**重复**也很简单，我们在判断用户是否有权限的时候，只要找到有匹配的权限，就停止查找，直接返回。

“资源”和“操作”放到Java对象来说，大概就是对数据库的增删改查的权限。而在一个Web系统中，如果我们的系统对外提供的接口是基于HTTP的，那么我们可以使用**HTTP方法+URL**来唯一定位一个“权限”(Permission)。在这里，**HTTP方法**就是一个“操作”(Action)，而**URL**就是一个“资源”(Resource)。

## 用户的权限存放在哪里？
肯定是放在数据库。但权限是需要在每个请求都需要去拦截判断的，所以频繁去取数据库肯定不行。一种解决方案是在数据库持久层做一个缓存，在“修改用户权限”的时候去刷新这个缓存。

另一种方案是用户在第一次登录的时候就读出来放到session或者redis缓存里，在“修改用户权限”的时候同时去修改session（或缓存）里面的权限，并同时（或者异步）更新数据库里面的权限数据。

## UI
用户没有相应的权限应该怎样表现？

- 如果用户未登录，而出发了需要登录才能进行的操作，那么引导用户进入登录页面。
- 如果用户已登录，但进行了没有权限的操作，那么可以通过“弹出框”提示或者将用户导入到一个“403”页面。

可不可以从UI上进一步优化用户的体验呢？

可以，我们可以将后端的权限（Permission）跟前端的UI关联起来。比如一个按钮，它关联了一个权限。用户在拥有相关后端权限的时候，这个按钮是“可见”的（或者Enable）的。

那么如果是一个后台管理系统，用户不应该有某个页面(Page)的权限呢？

在**前后端分离**的系统中，这一块**显示与不显示某个页面/导航菜单**是由前端的路由配置和导航条配置来控制的。但是它的权限信息仍然是需要存储在后端数据库里面的。而且可能是一个Json格式。在关系型数据库中，我们可以用一个长文本来存储这个信息。然后当用户第一次登陆的时候，返回这个信息。前端存储起来（比如SessionStorage或者LocalStorage)。

在更新上述配置时，怎么办呢？首先前端更新自己的存储，然后发送请求到后端，后端异步去更新数据库里面的信息。

**UI**与权限这块的难点是如何把UI组件（按钮、表格、页面等）于后端的接口权限（HTTP接口）相关联起来。如果不关联的话，管理者需要维护两套权限，非常麻烦。而如果在交付之前就把“接口”与“UI组件”绑定，网站管理者只需要维护UI组件的权限，就非常方便了。而UI组件具有多样性（按钮、表格、页面等），所以需要约定一个"key"来表示。比如`btn:addRole`、`table:users`、`page:userList`等。

# 总结
综上，做好一个权限系统并不简单。要考虑到它的安全性，灵活性，扩展性，易用性。

后续文章会使用**Spring Security**与**Vue**逐步搭建一个满足上述讨论的通用前后端分离的Web权限管理系统系统，敬请期待！